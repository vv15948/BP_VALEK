function [q_path, joint_path, u1, u2, goal_flag] = rrt_star_6dof_connect_02(q_start, q_goal, voxel_grid, range)

% Plánování probíhá pro první 4 klouby.
% Zbylé 2 jsou dopočítány jednoduše interpolací

% inicializace
u1 = 0; u2 = 0; goal_flag = false;
goal_idx_start = 0; goal_idx_goal = 0;


% Nastavení parametrů
max_step_per_joint = [
    0.25;   % q1
    0.2;    % q2
    0.15;   % q3
    0.1     % q4
];
max_iter = 3000;
goal_tolerance = 0.15;
joint_limits = repmat([-2*pi, 2*pi], 6, 1);


% Startovní nastavení stromů
Q_start = q_start(1:4);
Q_goal = q_goal(1:4);
P_start = 0;
P_goal = 0;

tree_direction = 1;
goal_bias = 0.4;


%% Hlavní smyčka 
for iter = 1:max_iter

    % Výběr náhodného bodu/cílového podle nastavení goal_bias
    if rand < goal_bias
        q_rand = (tree_direction == 1) * Q_goal(:,1) + (tree_direction == -1) * Q_start(:,1);
    else
        q_rand = joint_limits(1:4,1) + (joint_limits(1:4,2) - joint_limits(1:4,1)) .* rand(4,1);
    end

    % Rozšíření stromu ve směru ke q_rand
    [q_new_start, idx_nearest_s] = extend_tree_matrix(Q_start, q_rand, max_step_per_joint);
    if isempty(q_new_start), continue; end
    
    % Kolizní kontrola 
    [fk_pos_s] = forward_kinematics_ur5e(q_new_start);
    if any(fk_pos_s(:,3) < -0.15), continue; end
    if is_joint_in_collision(fk_pos_s, voxel_grid, range), u1 = u1 + 1; continue; end
    if is_robot_model_in_collision(fk_pos_s, voxel_grid, range), u2 = u2 + 1; continue; end
    
    % Přidání nového bodu do stromu
    Q_start(:,end+1) = q_new_start;
    P_start(end+1) = idx_nearest_s;

    % Vyhledání njebližšího bodu ve druhém stromě
    distances = vecnorm(Q_goal - q_new_start, 2, 1);
    [~, idx_nearest_g] = min(distances);
    q_near = Q_goal(:,idx_nearest_g);
    dist_to_goal = norm(q_new_start - q_goal(1:4));
    % Kolikrát se maximálně pokusíme udělat kroků od druhého stromu k
    % prvnímu
    max_s = 2;

    % Rozšiřování druhého stromu
    s=0;
    while true
        direction = q_new_start - q_near;
        dist = norm(direction);
        if dist < 1e-6, break; end

        % Vytvoření nového bodu
        q_new_goal = q_near + max_step_per_joint .* direction / dist;
% toto me zajima
% Ověř, zda se q_new_goal přibližuje ke q_goal (nevrací se zpět)
if norm(q_new_goal - q_goal(1:4)) > norm(q_near - q_goal(1:4))+0.2
    break;  % pokračování by vedlo od cíle, ukončíme rozšiřování
end

        % Kolizní kontrola
        [fk_pos_g] = forward_kinematics_ur5e(q_new_goal);
        if any(fk_pos_g(:,3) < -0.15), break; end
        if is_joint_in_collision(fk_pos_g, voxel_grid, range), u1 = u1 + 1; break; end
        if is_robot_model_in_collision(fk_pos_g, voxel_grid, range), u2 = u2 + 1; break; end

        % Přidání bodu do stromu
        Q_goal(:,end+1) = q_new_goal;
        P_goal(end+1) = idx_nearest_g;
        idx_nearest_g = size(Q_goal,2);
        q_near = q_new_goal;

        % Nalezení nejbližšího bodu 1. stromu k právě vytvořenému
        distances_to_start = vecnorm(Q_start - q_new_goal, 2, 1);
        [min_dist, min_idx] = min(distances_to_start);

        % Kontrola, jestli už se můžou propojit
        if min_dist < goal_tolerance
            goal_idx_start = min_idx;
            goal_idx_goal = size(Q_goal,2);
            goal_flag = true;
            disp('Cíl dosažen');
            break;
        end


        s = s+1;
        if s > max_s
            break;
        end
    end

if goal_flag, break; end

    % Stromy se nepropojily, tak si vymění role
    [Q_start, Q_goal] = deal(Q_goal, Q_start);
    [P_start, P_goal] = deal(P_goal, P_start);
    tree_direction = -tree_direction;
end

% Pokud se stromy nepropojily
if goal_flag == false
    q_path = [q_start, q_start];
    joint_path = repmat(zeros(6,3), [2, 1, 1]);
    disp('Stojíme – cíl nenalezen.');
    return;
end

% Posloupnost, jak na sebe jednotlivé body ve stromech navazují
idx_s = reconstruct_path_matrix(P_start, goal_idx_start);
idx_g = reconstruct_path_matrix(P_goal, goal_idx_goal);

% Správné seřazení stromů start -> goal
if norm(Q_start(:,idx_s(1)) - q_start(1:4)) > norm(Q_goal(:,idx_g(1)) - q_start(1:4))
    [Q_start, Q_goal] = deal(Q_goal, Q_start);
    [P_start, P_goal] = deal(P_goal, P_start);
    [idx_s, idx_g] = deal(idx_g, idx_s);
end

% Spojení do jedné části
q_path_4dof = [Q_start(:,idx_s), fliplr(Q_goal(:,idx_g))];
N = size(q_path_4dof,2);

% Doplnění 5. a 6. kloubu do konfigurací pomocí interpolace
q_path = zeros(6, N);
q_path(1:4,:) = q_path_4dof;
for i = 1:N
    alpha = (i-1)/(N-1);
    q_path(5:6,i) = (1 - alpha) * q_start(5:6) + alpha * q_goal(5:6);
end

% Výpočet polohy jednotlivých kloubů pro každou konfiguraci q_path
joint_path = zeros(N,5,3);
for i = 1:N
    joint_pos = forward_kinematics_ur5e_full(q_path(:,i));
    joint_path(i,1:4,:) = joint_pos(1:4,:);
    joint_path(i,5,:) = joint_pos(7,:);
end



end


%% rozšíření stromu Q k bodu q_target
% Najde nejbližší bod ve stromu a udělá krok tímto směrem
function [q_new, best_parent_idx] = extend_tree_matrix(Q, q_target, max_step_per_joint)


    % Nalezení nejbližšího bodu ke q
    distances = vecnorm(Q - q_target, 2, 1);
    [~, best_parent_idx] = min(distances);


    % Vytvoříme nový bod směrem k cíli z nejlepšího rodiče
    q_near = Q(:,best_parent_idx);
    dq = wrap_angle_diff(q_target, q_near);
    dq_clipped = max(min(dq, max_step_per_joint), -max_step_per_joint);
    q_new = q_near + dq_clipped;

    % Ochrana proti NaN
    if any(isnan(q_new))
        q_new = [];
    end
end

function diff = wrap_angle_diff(q1, q2)
    diff = atan2(sin(q1 - q2), cos(q1 - q2));
end



%% Rekonstrukce posloupnosti indexů od kořene ke koncovému bodu

function idx_path = reconstruct_path_matrix(parent_list, idx)
    idx_path = idx;
    
    % Zpětné procházení rodičů, až k 0
    while parent_list(idx) ~= 0
        idx = parent_list(idx);
        idx_path = [idx, idx_path]; % Seřazení od startu k cíli
    end
end


function q_list = interp_linspace(q1, q2, num_steps)
% Interpolace mezi dvěma konfiguracemi v joint space
q_list = zeros(length(q1), num_steps);
for i = 1:length(q1)
    q_list(i,:) = linspace(q1(i), q2(i), num_steps);
end
end
function valid = is_valid(q1, q2, voxel_grid, range)
% Vrací true, pokud je interpolace mezi q1 a q2 bez kolizí

steps = 5;
for i = 0:steps
    alpha = i / steps;
    q_interp = (1 - alpha) * q1 + alpha * q2;
    
    fk_pos = forward_kinematics_ur5e(q_interp);
    if any(fk_pos(:,3) < -0.15), valid = false; return; end

    if is_joint_in_collision(fk_pos, voxel_grid, range)
        valid = false;
        return;
    end

    if is_robot_model_in_collision(fk_pos, voxel_grid, range)
        valid = false;
        return;
    end
end

valid = true;
end
